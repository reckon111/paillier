#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    char *p,*q;
    char s[10] = "sdjfkdf";
    int slen;
    int size = 4;

    p = s;
    q = (char*)malloc((size+1)*sizeof(char)); // 注意'\0'存在，size+1 防止越界
    strncpy(q, p+1, size);
    puts(q);
    free(q);
    return 0;
}

// realloc函数
// 语法
// 原型：extern void *realloc(void mem_address, unsigned int newsize);
// 指针名=（数据类型）realloc（要改变内存大小的指针名，新的大小）。

// 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。

// 如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL。
// 如果堆空间不足，函数调用失败，那么可能会造成数据丢失和free失败产生的内存泄漏

// malloc:
// malloc分配的内存大小至少为参数所指定的字节数
// malloc的返回值是一个指针，指向一段可用内存的起始位置，指向一段可用内存的起始地址，
// malloc和free是配对的，如果申请后不释放就是内存泄露，
// 如果无故释放那就是什么也没做，释放只能释放一次，
// 如果一块空间释放两次或者两次以上会出现错误（但是释放空指针例外，释放空指针也等于什么也没做，所以释放多少次都是可以的。）

// malloc 必须和 free 成对出现，如果申请了，就一定要释放，如果你一直需要它，申请一个全局变量放在ram中会是一个更好的选择。
// 申请的malloc一定要注意到它是否是NULL，否则后续工作都会出问题。
// 注意到malloc申请的内存不要越界是一个程序员的必修课。
// 1. 你动用了系统未知的内存，并且用了一些方法给它赋值，那么原来那块内存的信息就会被抹去，会对整个系统造成一个极大的危害以及隐患。
// 2. 值得注意的是，最恐怖的也是在此，如果你动用的不是系统内存，C语言编译甚至不会报错，那么带着这个 有着巨大隐患的系统，遗害无穷。